#pragma once

#ifndef FREEFORM2_INC_EXECUTABLE_H
#define FREEFORM2_INC_EXECUTABLE_H

#include <basic_types.h>
#include <boost/noncopyable.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/shared_ptr.hpp>
// Included for the CompilerResults object.
#include "FreeForm2Compiler.h"
#include <memory>

class StreamFeatureInput;

namespace FreeForm2
{
    class ExecutableImpl;
    class Result;
    class Type;

    // An executable is something that can simply be executed, and not much
    // more (knows its type, because that's unavoidable).
    class Executable : boost::noncopyable
    {
    public:
        // Features are 32-bit unsigned integer quantities generated by a
        // variety of feature generators.
        typedef UInt32 FeatureType;

        // Inputs take features and turn them into floating point numbers.
        typedef double InputType;
        typedef float OutputType;

        // Constructor, taking the implementation object.
        Executable(std::auto_ptr<ExecutableImpl> p_impl);

        // Evaluate a program, returning a result. The StreamFeatureInput may
        // be NULL, in which case default values are used for its members.
        boost::shared_ptr<Result> Evaluate(StreamFeatureInput* p_input,
                                           const FeatureType p_features[]) const;


        // Evaluate a program of aggregated freeform syntax.
        boost::shared_ptr<FreeForm2::Result>
        Evaluate(const Executable::FeatureType* const* p_features,
                 UInt32 p_currentDocument,
                 UInt32 p_documentCount,
                 Int64* p_cache) const;

        // Attempt to get a function returning a pointer to a function that can
        // be called directly.  This will only work if the executable produces a
        // floating point number, and various other conditions.
        typedef float (*DirectEvalFun)(StreamFeatureInput*, const FeatureType[], OutputType[]);
        DirectEvalFun EvaluationFunction() const;

        // Attempt to get a function returning a pointer to a function that can
        // be called to evaluate aggregated freeform.
        typedef float (*AggregatedEvalFun)(const FeatureType* const*, UInt32, UInt32, Int64*, OutputType[]);
        AggregatedEvalFun AggregatedEvaluationFunction() const;

        // Get the output type of the executable.
        const Type& GetType() const;

        // Get the size of external memory.
        size_t GetExternalSize() const;

        // Implementation accessor.
        const ExecutableImpl& GetImplementation() const;

    private:
        // Pointer to implementation class (pimpl idiom).
        boost::scoped_ptr<ExecutableImpl> m_impl;
    };

    // The class holds the results of the Compiler::Compile method for an
    // Executable compiler.
    class ExecutableCompilerResults : public CompilerResults
    {
    public:
        // Construct a results object for an executable.
        explicit ExecutableCompilerResults(const boost::shared_ptr<Executable>& p_executable);

        // Get the executable held by this object.
        const boost::shared_ptr<Executable>& GetExecutable() const;

    private:
        // The executable pointer passed to the constructor.
        const boost::shared_ptr<Executable> m_executable;
    };
}

#endif
