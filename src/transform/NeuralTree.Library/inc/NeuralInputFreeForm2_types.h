
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// 
//     Tool     : bondc, Version=3.0.1, Build=bond-git.retail.0
//     Template : Microsoft.Bond.Rules.dll#Rules_BOND_CPP.tt
//     File     : NeuralInputFreeForm2_types.h
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma once


#include <bond/core/bond_version.h>
#if BOND_MAJOR_VERSION_MIN_SUPPORTED > 3 \
    || (BOND_MAJOR_VERSION_MIN_SUPPORTED == 3 && BOND_MINOR_VERSION_MIN_SUPPORTED > 1)
#error This file was generated by an older Bond compiler which is \
       incompatible with current Bond library. Please regenerate \
       with the latest Bond compiler.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>
#include "NeuralInput_types.h"

namespace DynamicRank
{

// This is per ranker level info: it merge all freeform2 code. 
struct FreeForm2CodeBondData 
{
    // 1: optional vector<uint64> m_offsets
    std::vector<uint64_t> m_offsets;

    // 2: optional string m_code
    std::string m_code;

    FreeForm2CodeBondData()
    {
    }


    // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    FreeForm2CodeBondData(const FreeForm2CodeBondData& /*_bond_rhs*/) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    FreeForm2CodeBondData(FreeForm2CodeBondData&& _bond_rhs) BOND_NOEXCEPT_IF((true
        && std::is_nothrow_move_constructible< std::vector<uint64_t> >::value
        && std::is_nothrow_move_constructible< std::string >::value
        ))
        : m_offsets(std::move(_bond_rhs.m_offsets)),
          m_code(std::move(_bond_rhs.m_code))
    {
    }
#endif


    template<typename Allocator>
    explicit
    FreeForm2CodeBondData(Allocator* _bond_allocator)
        : m_offsets(*_bond_allocator),
          m_code(*_bond_allocator)
    {
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    FreeForm2CodeBondData& operator=(const FreeForm2CodeBondData& _bond_rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    FreeForm2CodeBondData& operator=(FreeForm2CodeBondData&& _bond_rhs)
    {
        FreeForm2CodeBondData(std::move(_bond_rhs)).swap(*this);
        return *this;
    }
#endif


    bool operator==(const FreeForm2CodeBondData& _bond_other) const
    {
        return true
            && (m_offsets == _bond_other.m_offsets)
            && (m_code == _bond_other.m_code);
    }


    bool operator!=(const FreeForm2CodeBondData& _bond_other) const
    {
        return !(*this == _bond_other);
    }


    void swap(FreeForm2CodeBondData& _bond_other)
    {
        using std::swap;
        swap(m_offsets, _bond_other.m_offsets);
        swap(m_code, _bond_other.m_code);
    }


    struct Schema;


protected:
    void InitMetadata(const char* /*_bond_name*/, const char* /*_bond_full_name*/)
    {
    }
};


inline void swap(FreeForm2CodeBondData& _bond_left, FreeForm2CodeBondData& _bond_right)
{
    _bond_left.swap(_bond_right);
}



// NeuralInputFreeForm2BondData 
struct NeuralInputFreeForm2BondData : public ::DynamicRank::NeuralInputBondData
{
    // 1: optional vector<uint32> m_features
    std::vector<uint32_t> m_features;

    // 2: optional string m_input
    // Source code. In production case we want to not save it to save space.
    std::string m_input;

    NeuralInputFreeForm2BondData()    {
        InitMetadata("NeuralInputFreeForm2BondData", "DynamicRank.NeuralInputFreeForm2BondData");
    }


    NeuralInputFreeForm2BondData(const NeuralInputFreeForm2BondData& _bond_rhs)
        : ::DynamicRank::NeuralInputBondData(_bond_rhs),
          m_features(_bond_rhs.m_features),
          m_input(_bond_rhs.m_input)    {
        InitMetadata("NeuralInputFreeForm2BondData", "DynamicRank.NeuralInputFreeForm2BondData");
    }


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    NeuralInputFreeForm2BondData(NeuralInputFreeForm2BondData&& _bond_rhs) BOND_NOEXCEPT_IF((true
        && std::is_nothrow_move_constructible< ::DynamicRank::NeuralInputBondData >::value
        && std::is_nothrow_move_constructible< std::vector<uint32_t> >::value
        && std::is_nothrow_move_constructible< std::string >::value
        ))
        : ::DynamicRank::NeuralInputBondData(std::move(_bond_rhs)),
          m_features(std::move(_bond_rhs.m_features)),
          m_input(std::move(_bond_rhs.m_input))
    {
    }
#endif


    template<typename Allocator>
    explicit
    NeuralInputFreeForm2BondData(Allocator* _bond_allocator)
        : ::DynamicRank::NeuralInputBondData(_bond_allocator),
          m_features(*_bond_allocator),
          m_input(*_bond_allocator)    {
        InitMetadata("NeuralInputFreeForm2BondData", "DynamicRank.NeuralInputFreeForm2BondData");
    }


    // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
    NeuralInputFreeForm2BondData& operator=(const NeuralInputFreeForm2BondData& _bond_rhs) = default;
#endif


#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
    NeuralInputFreeForm2BondData& operator=(NeuralInputFreeForm2BondData&& _bond_rhs)
    {
        NeuralInputFreeForm2BondData(std::move(_bond_rhs)).swap(*this);
        return *this;
    }
#endif


    bool operator==(const NeuralInputFreeForm2BondData& _bond_other) const
    {
        return true
            && (static_cast<const ::DynamicRank::NeuralInputBondData&>(*this) == static_cast<const ::DynamicRank::NeuralInputBondData&>(_bond_other))
            && (m_features == _bond_other.m_features)
            && (m_input == _bond_other.m_input);
    }


    bool operator!=(const NeuralInputFreeForm2BondData& _bond_other) const
    {
        return !(*this == _bond_other);
    }


    void swap(NeuralInputFreeForm2BondData& _bond_other)
    {
        using std::swap;
        ::DynamicRank::NeuralInputBondData::swap(_bond_other);
        swap(m_features, _bond_other.m_features);
        swap(m_input, _bond_other.m_input);
    }


    struct Schema;


protected:
    void InitMetadata(const char* _bond_name, const char* _bond_full_name)
    {
        ::DynamicRank::NeuralInputBondData::InitMetadata(_bond_name, _bond_full_name);
    }
};


inline void swap(NeuralInputFreeForm2BondData& _bond_left, NeuralInputFreeForm2BondData& _bond_right)
{
    _bond_left.swap(_bond_right);
}



} // namespace DynamicRank
