/*!
 * Copyright (c) 2021 Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See LICENSE file in the project root for license information.
 */

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Tool     : bondc, Version=3.0.1, Build=bond-git.retail.0
//     Template : Microsoft.Bond.Rules.dll#Rules_BOND_CPP.tt
//     File     : NeuralInputFreeForm2_types.h
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>
#if BOND_MAJOR_VERSION_MIN_SUPPORTED > 3 || (BOND_MAJOR_VERSION_MIN_SUPPORTED == 3 && BOND_MINOR_VERSION_MIN_SUPPORTED > 1)
#error This file was generated by an older Bond compiler which is \
       incompatible with current Bond library. Please regenerate \
       with the latest Bond compiler.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>
#include "NeuralInput_types.h"

namespace DynamicRank
{

    // This is per ranker level info: it merge all freeform2 code.
    struct FreeForm2CodeBondData
    {
        // 1: optional vector<uint64> m_offsets
        std::vector<uint64_t> m_offsets;

        // 2: optional string m_code
        std::string m_code;

        FreeForm2CodeBondData()
        {
        }

        // Compiler generated copy ctor OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        FreeForm2CodeBondData(const FreeForm2CodeBondData & /*_bond_rhs*/) = default;
#endif

#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        FreeForm2CodeBondData(FreeForm2CodeBondData &&_bond_rhs) BOND_NOEXCEPT_IF((true && std::is_nothrow_move_constructible<std::vector<uint64_t> >::value && std::is_nothrow_move_constructible<std::string>::value))
            : m_offsets(std::move(_bond_rhs.m_offsets)),
              m_code(std::move(_bond_rhs.m_code))
        {
        }
#endif

        template <typename Allocator>
        explicit FreeForm2CodeBondData(Allocator *_bond_allocator)
            : m_offsets(*_bond_allocator),
              m_code(*_bond_allocator)
        {
        }

        // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        FreeForm2CodeBondData &operator=(const FreeForm2CodeBondData &_bond_rhs) = default;
#endif

#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        FreeForm2CodeBondData &operator=(FreeForm2CodeBondData &&_bond_rhs)
        {
            FreeForm2CodeBondData(std::move(_bond_rhs)).swap(*this);
            return *this;
        }
#endif

        bool operator==(const FreeForm2CodeBondData &_bond_other) const
        {
            return true && (m_offsets == _bond_other.m_offsets) && (m_code == _bond_other.m_code);
        }

        bool operator!=(const FreeForm2CodeBondData &_bond_other) const
        {
            return !(*this == _bond_other);
        }

        void swap(FreeForm2CodeBondData &_bond_other)
        {
            using std::swap;
            swap(m_offsets, _bond_other.m_offsets);
            swap(m_code, _bond_other.m_code);
        }

        struct Schema;

    protected:
        void InitMetadata(const char * /*_bond_name*/, const char * /*_bond_full_name*/)
        {
        }
    };

    inline void swap(FreeForm2CodeBondData &_bond_left, FreeForm2CodeBondData &_bond_right)
    {
        _bond_left.swap(_bond_right);
    }

    // NeuralInputFreeForm2BondData
    struct NeuralInputFreeForm2BondData : public ::DynamicRank::NeuralInputBondData
    {
        // 1: optional vector<uint32> m_features
        std::vector<uint32_t> m_features;

        // 2: optional string m_input
        // Source code. In production case we want to not save it to save space.
        std::string m_input;

        NeuralInputFreeForm2BondData()
        {
            InitMetadata("NeuralInputFreeForm2BondData", "DynamicRank.NeuralInputFreeForm2BondData");
        }

        NeuralInputFreeForm2BondData(const NeuralInputFreeForm2BondData &_bond_rhs)
            : ::DynamicRank::NeuralInputBondData(_bond_rhs),
              m_features(_bond_rhs.m_features),
              m_input(_bond_rhs.m_input)
        {
            InitMetadata("NeuralInputFreeForm2BondData", "DynamicRank.NeuralInputFreeForm2BondData");
        }

#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        NeuralInputFreeForm2BondData(NeuralInputFreeForm2BondData &&_bond_rhs) BOND_NOEXCEPT_IF((true && std::is_nothrow_move_constructible< ::DynamicRank::NeuralInputBondData>::value && std::is_nothrow_move_constructible<std::vector<uint32_t> >::value && std::is_nothrow_move_constructible<std::string>::value))
            : ::DynamicRank::NeuralInputBondData(std::move(_bond_rhs)),
              m_features(std::move(_bond_rhs.m_features)),
              m_input(std::move(_bond_rhs.m_input))
        {
        }
#endif

        template <typename Allocator>
        explicit NeuralInputFreeForm2BondData(Allocator *_bond_allocator)
            : ::DynamicRank::NeuralInputBondData(_bond_allocator),
              m_features(*_bond_allocator),
              m_input(*_bond_allocator)
        {
            InitMetadata("NeuralInputFreeForm2BondData", "DynamicRank.NeuralInputFreeForm2BondData");
        }

        // Compiler generated operator= OK
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        NeuralInputFreeForm2BondData &operator=(const NeuralInputFreeForm2BondData &_bond_rhs) = default;
#endif

#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        NeuralInputFreeForm2BondData &operator=(NeuralInputFreeForm2BondData &&_bond_rhs)
        {
            NeuralInputFreeForm2BondData(std::move(_bond_rhs)).swap(*this);
            return *this;
        }
#endif

        bool operator==(const NeuralInputFreeForm2BondData &_bond_other) const
        {
            return true && (static_cast<const ::DynamicRank::NeuralInputBondData &>(*this) == static_cast<const ::DynamicRank::NeuralInputBondData &>(_bond_other)) && (m_features == _bond_other.m_features) && (m_input == _bond_other.m_input);
        }

        bool operator!=(const NeuralInputFreeForm2BondData &_bond_other) const
        {
            return !(*this == _bond_other);
        }

        void swap(NeuralInputFreeForm2BondData &_bond_other)
        {
            using std::swap;
            ::DynamicRank::NeuralInputBondData::swap(_bond_other);
            swap(m_features, _bond_other.m_features);
            swap(m_input, _bond_other.m_input);
        }

        struct Schema;

    protected:
        void InitMetadata(const char *_bond_name, const char *_bond_full_name)
        {
            ::DynamicRank::NeuralInputBondData::InitMetadata(_bond_name, _bond_full_name);
        }
    };

    inline void swap(NeuralInputFreeForm2BondData &_bond_left, NeuralInputFreeForm2BondData &_bond_right)
    {
        _bond_left.swap(_bond_right);
    }

} // namespace DynamicRank
